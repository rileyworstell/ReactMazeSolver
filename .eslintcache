[{"/Users/rileyworstell/Documents/Maze Solving/maze-solver/src/components/block/block.jsx":"1","/Users/rileyworstell/Documents/Maze Solving/maze-solver/src/components/selected/selected.jsx":"2","/Users/rileyworstell/Documents/Maze Solving/maze-solver/src/index.js":"3","/Users/rileyworstell/Documents/Maze Solving/maze-solver/src/components/button/button.jsx":"4","/Users/rileyworstell/Documents/Maze Solving/maze-solver/src/components/grid/grid.jsx":"5","/Users/rileyworstell/Documents/Maze Solving/maze-solver/src/App.js":"6","/Users/rileyworstell/Documents/Maze Solving/maze-solver/src/components/path/path.jsx":"7","/Users/rileyworstell/Documents/Maze Solving/maze-solver/src/algorithms/BFS.js":"8","/Users/rileyworstell/Documents/Maze Solving/maze-solver/src/algorithms/DFS.js":"9","/Users/rileyworstell/Documents/Maze Solving/maze-solver/src/algorithms/initializeArr.js":"10","/Users/rileyworstell/Documents/Maze Solving/maze-solver/src/components/color/color.jsx":"11"},{"size":3360,"mtime":1608606718833,"results":"12","hashOfConfig":"13"},{"size":309,"mtime":1607484534477,"results":"14","hashOfConfig":"15"},{"size":500,"mtime":1607229065098,"results":"16","hashOfConfig":"13"},{"size":810,"mtime":1608261012302,"results":"17","hashOfConfig":"13"},{"size":764,"mtime":1622423183812,"results":"18","hashOfConfig":"15"},{"size":6725,"mtime":1608652799402,"results":"19","hashOfConfig":"13"},{"size":369,"mtime":1612484776390,"results":"20","hashOfConfig":"15"},{"size":2939,"mtime":1622423183807,"results":"21","hashOfConfig":"15"},{"size":2987,"mtime":1622423183808,"results":"22","hashOfConfig":"15"},{"size":369,"mtime":1612562966818,"results":"23","hashOfConfig":"15"},{"size":552,"mtime":1612562966822,"results":"24","hashOfConfig":"15"},{"filePath":"25","messages":"26","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"nvsvih",{"filePath":"27","messages":"28","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1lcyptb",{"filePath":"29","messages":"30","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"31"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"34","messages":"35","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"36","messages":"37","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"38"},{"filePath":"39","messages":"40","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"41","messages":"42","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"43","messages":"44","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"45","messages":"46","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"47","messages":"48","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/rileyworstell/Documents/Maze Solving/maze-solver/src/components/block/block.jsx",[],"/Users/rileyworstell/Documents/Maze Solving/maze-solver/src/components/selected/selected.jsx",[],"/Users/rileyworstell/Documents/Maze Solving/maze-solver/src/index.js",[],["49","50"],"/Users/rileyworstell/Documents/Maze Solving/maze-solver/src/components/button/button.jsx",[],"/Users/rileyworstell/Documents/Maze Solving/maze-solver/src/components/grid/grid.jsx",["51"],"/Users/rileyworstell/Documents/Maze Solving/maze-solver/src/App.js",["52","53"],"import './App.css';\nimport React, { Component} from 'react';\nimport {Grid} from './components/grid/grid.jsx'\nimport {Button} from './components/button/button.jsx'\nimport {Selected} from './components/selected/selected.jsx'\nimport {Path} from './components/path/path.jsx'\nimport {Arr} from './algorithms/initializeArr'\nimport {Color} from './components/color/color.jsx'\n\nlet initialValues = Arr(20);\nvar arr = initialValues[0];\nvar num = initialValues[1];\n\nclass App extends Component {\n\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      gridArr: arr,\n      gridLength: num,\n      startPointSelecter: 0 ,\n      s: null,\n      path: null,\n      colorScheme: 1,\n      gridClassName: 'mainGrid12',\n      isClickedDown: 0\n    };\n    this.changeBlock = this.changeBlock.bind(this);\n    this.recreateGrid = this.recreateGrid.bind(this);\n    this.pointSelecter = this.pointSelecter.bind(this);\n    this.recreateGrid = this.recreateGrid.bind(this);\n    this.updatePathMaze = this.updatePathMaze.bind(this);\n    this.awaitUpdatePath = this.awaitUpdatePath.bind(this);\n    this.changeColor = this.changeColor.bind(this);\n    this.changeSize = this.changeSize.bind(this);\n    this.isDown = this.isDown.bind(this);\n  }\n\n\nchangeBlock(x, path=null) {\n  if (path !== null) {\n    this.setState({gridArr: x,  path: path});\n  }\n  this.setState({gridArr: x});\n}\n\nupdatePathMaze = (x, i, leng) => {\n  var time = 15;\n  if (i > leng) {\n    time =50;\n  }\n  let promise = new Promise((resolve, reject) => {\n    this.setState({gridArr: x}, () => {\n      setTimeout(() => { \n      i++;\n      resolve(i);\n    }, time);\n    });\n  });\n    return promise;\n}\n\n\nasync awaitUpdatePath(x, path, s, e, leng) {\n  // console.log(path);\n  // i is the promise and when the promise is returned it is incremented (this is for UI purposes)\n  var i = 0;\n  while ( i < path.length) {\n    // the first part of path is all of the visited up until the variable length and then that is the path to solve\n    if ( i <= leng) {\n      x[path[i][0][0]][path[i][0][1]] = \"V\";\n    } else {\n      x[path[i][0][0]][path[i][0][1]] = \"Solved\";\n    }\n    const fetch = await this.updatePathMaze(x, i, leng);\n    i = fetch;\n  }\n\n  // resets starting and ending points\n  x[path[leng][0][0]][path[leng][0][1]] = \"Solved\"\n  x[s[0]][s[1]] = \"S\";\n  x[e[0]][e[1]] = \"E\";\n  // this splits that path to solve from the whole path\n  path.splice(0, leng);\n  this.setState({gridArr: x, path: path});\n \n}\n\npointSelecter(point) {\n    if (point !== [-1, -1]) {\n      this.setState({startPointSelecter: this.state.startPointSelecter + 1,\n                  s: point});\n    }else {\n     this.setState({startPointSelecter: this.state.startPointSelecter + 1});\n    }\n}\n\nchangeColor() {\n if (this.state.colorScheme !== 2) {\n   this.setState({colorScheme: 2});\n }\n else {\n  this.setState({colorScheme: 1});\n }\n}\n\nisDown() {\n  if (this.state.isClickedDown !== 1) {\n    this.setState({isClickedDown: 1});\n  }\n  else {\n   this.setState({isClickedDown: 0});\n  }\n }\n\nchangeSize() {\n  if (this.state.gridLength === 10) {  \n    this.setState({gridLength: 20, gridClassName: 'mainGrid12'});\n    this.recreateGrid(20);\n  }\n  else {\n   this.setState({gridLength: 10, gridClassName: 'mainGrid'});\n   this.recreateGrid(10);\n  }\n  \n }\n\n\nrecreateGrid(x, notWalls) {\n  var i;\n  var j;\n  var arr = [];\n  var num;\n  if (x === null || x === undefined) {\n    num = this.state.gridLength;\n  }\n  else {\n    num = x;\n  }\n  if (notWalls === true) {\n    arr = this.state.gridArr;\n    for (i = 0; i < num; i++) {\n      for (j = 0; j < num; j++) {\n        if (arr[i][j] !== \"1\") {\n          arr[i][j] = \"0\";\n        }\n          \n      }\n    }\n    arr[num-1][num-1] = \"E\";\n    this.setState({gridArr: arr,\n                  startPointSelecter: 0,\n                  path: null\n    }); \n  }\n\n  else {\n  for (i = 0; i < num; i++) {\n    arr[i] = new Array(num);\n  }\n  for (i = 0; i < num; i++) {\n    for (j = 0; j < num; j++) {\n        arr[i][j] = \"0\";\n    }\n  }\n  arr[num-1][num-1] = \"E\";\n  this.setState({gridArr: arr,\n                startPointSelecter: 0 ,\n                s: null,\n                path: null,\n  }); \n}\n}\n  render() {\n  return (\n    <div draggable={false} onDragOver={() => this.isDown()} onMouseDown={() => this.isDown()} onMouseUp={() => this.isDown()} className=\"App\">\n     <div>This is a maze solver!\n       <br/> Select Blocks to make them walls (red) and optionally select starting point and make a blue block. \n       <br/> Yellow will show the algorithm working and Green is the path. \n       <br/> Then start the BFS. \n       <br/> If you do not select a start point, one will be assigned for you. </div>\n\n     <Selected startPointSelecter={this.state.startPointSelecter} \n          pointSelecter={this.pointSelecter}\n          className={\"selectedButton\"}\n          text={\"Set Starting Point\"}/>\n\n\n    <Button gridLength={this.state.gridLength} \n          clickDo={'recreateGrid'}\n          recreateGrid={this.recreateGrid}\n          path={this.state.path}\n          changeBlock={this.changeBlock} \n          gridArr={this.state.gridArr} \n          className={\"redButton\"} \n          text={\"Restart Grid\"}/>\n\n     <Button gridLength={this.state.gridLength} \n          clickDo={'bfs'}\n          gridLength={this.state.gridLength}\n          awaitUpdatePath={this.awaitUpdatePath}\n          path={this.state.path}\n          changeBlock={this.changeBlock} \n          recreateGrid={this.recreateGrid}\n          gridArr={this.state.gridArr} \n          className={\"button\"} \n          s={this.state.s}\n          text={\"Start BFS\"}/>\n\n<Button gridLength={this.state.gridLength} \n          clickDo={'dfs'}\n          gridLength={this.state.gridLength}\n          awaitUpdatePath={this.awaitUpdatePath}\n          path={this.state.path}\n          changeBlock={this.changeBlock} \n          recreateGrid={this.recreateGrid}\n          gridArr={this.state.gridArr} \n          className={\"button\"} \n          s={this.state.s}\n          text={\"Start DFS\"}/>\n\n          <Color elector={1} changeColor={this.changeColor} text={\"Switch Colors\"} />\n          <Color  elector={2} changeSize={this.changeSize} text={\"Switch Size\"} />\n     <div></div> \n\n     <Grid gridLength={this.state.gridLength} \n          isDown={this.isDown}\n          isClickedDown={this.state.isClickedDown}\n          colorScheme={this.state.colorScheme}\n          changeBlock={this.changeBlock} \n          gridArr={this.state.gridArr} \n          s={this.state.s}\n          startPointSelecter={this.state.startPointSelecter}\n          pointSelecter={this.pointSelecter}\n          className={this.state.gridClassName}/> \n          <br />\n          <br />\n          <Path path={this.state.path}/>\n    </div>\n    \n  );\n  }\n}\n\nexport default App;\n","/Users/rileyworstell/Documents/Maze Solving/maze-solver/src/components/path/path.jsx",[],"/Users/rileyworstell/Documents/Maze Solving/maze-solver/src/algorithms/BFS.js",[],"/Users/rileyworstell/Documents/Maze Solving/maze-solver/src/algorithms/DFS.js",[],"/Users/rileyworstell/Documents/Maze Solving/maze-solver/src/algorithms/initializeArr.js",["54"],"/Users/rileyworstell/Documents/Maze Solving/maze-solver/src/components/color/color.jsx",[],{"ruleId":"55","replacedBy":"56"},{"ruleId":"57","replacedBy":"58"},{"ruleId":"59","severity":1,"message":"60","line":6,"column":9,"nodeType":"61","messageId":"62","endLine":6,"endColumn":12},{"ruleId":"63","severity":1,"message":"64","line":201,"column":11,"nodeType":"65","endLine":201,"endColumn":45},{"ruleId":"63","severity":1,"message":"64","line":213,"column":11,"nodeType":"65","endLine":213,"endColumn":45},{"ruleId":"66","severity":1,"message":"67","line":5,"column":9,"nodeType":"61","messageId":"68","endLine":5,"endColumn":12},"no-native-reassign",["69"],"no-negated-in-lhs",["70"],"no-unused-vars","'arr' is assigned a value but never used.","Identifier","unusedVar","react/jsx-no-duplicate-props","No duplicate props allowed","JSXAttribute","no-redeclare","'num' is already defined.","redeclared","no-global-assign","no-unsafe-negation"]